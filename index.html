<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Yhteinen sanaristikko (reaaliaikainen)</title>
  <style>
    :root { --cell: 34px; --gap: 2px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    body { margin:0; background:#f4f6fa; color:#0b1116; }
    .wrap { display:grid; grid-template-columns: 1fr 260px; gap:16px; align-items:start; width:min(98vw,1300px); margin:0 auto; padding:20px; }
    .left { }
    .right { position:sticky; top:12px; }

    h1 { font-size:22px; margin:0 0 6px 0; font-weight:700; }
    .subhint { font-size:14px; color:#334155; background:#e7eef9; border:1px solid #c9d9f8; padding:8px 10px; border-radius:10px; margin:6px 0 12px; }

    .status { font-size:12px; color:#475569; display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    .dot { width:8px; height:8px; border-radius:50%; background:#94a3b8; }
    .dot.ok { background:#16a34a; }
    .dot.err { background:#ef4444; }

    .grid-wrapper { display:inline-block; background:#e5e7eb; padding:8px; border-radius:12px; border:1px solid #d1d5db; }
    .labels-row, .grid-row { display:flex; }
    .label-cell { width:var(--cell); height:var(--cell); display:flex; align-items:center; justify-content:center; font-size:12px; color:#425466; }
    .grid { display:grid; grid-template-columns: repeat(var(--n), var(--cell)); gap:var(--gap); background:#d1d5db; padding:var(--gap); border-radius:8px; }
    .cell { width:var(--cell); height:var(--cell); display:grid; place-items:center; background:#ffffff; border-radius:6px; position:relative; border:1px solid #e5e7eb; }
    .cell input { width:100%; height:100%; text-align:center; font-weight:800; font-size:18px; text-transform:uppercase; background:transparent; border:none; color:#0b1116; outline:none; }
    .cell.black { background:#0f1720; border-color:#0f1720; }
    .cell.black input { visibility:hidden; pointer-events:none; }
    .cell.black::after { content:""; position:absolute; inset:0; border-radius:6px; background:repeating-linear-gradient(45deg, #0f1720 0 8px, #142237 8px 16px); opacity:.9; }

    .toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:12px 0 0; }
    .toolbar button, .toolbar input[type="text"], .toolbar input[type="file"], .toolbar label { background:#ffffff; color:#0b1116; border:1px solid #cbd5e1; border-radius:10px; padding:8px 10px; }
    .toolbar button:hover { background:#f1f5f9; cursor:pointer; }
    .toolbar .grow { flex:1; }
    a.link { color:#0b6bcb; text-decoration:underline; }

    .card { background:#ffffff; border:1px solid #cbd5e1; border-radius:12px; padding:12px; box-shadow:0 2px 10px #00000010; }
    .names { display:grid; grid-template-columns: 1fr; gap:8px; }
    .names input { width:100%; padding:10px; border:1px solid #cbd5e1; border-radius:10px; }
    .toggle { display:flex; align-items:center; gap:8px; font-size:14px; }

    @media (max-width: 860px){ .wrap{ grid-template-columns: 1fr; } .right{ position:static; } }
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1 id="title">Sanaristikko</h1>
    <div class="subhint">Klikkaa ruutua ja lisää kirjain. Ristikon huone on nettiosoitteen lopussa, Pekka lähettää linkin.</div>

    <div class="status"><span id="statusDot" class="dot"></span><span id="statusText">Yhteyttä muodostetaan…</span></div>

    <div id="gridWrapper" class="grid-wrapper"></div>

    <div class="toolbar" id="toolbar">
      <button id="save">Tallenna (.json)</button>
      <label>
        <input id="load" type="file" accept="application/json" style="display:none">
        <button id="loadBtn" type="button">Lataa (.json)</button>
      </label>
      <button id="clear">Tyhjennä ristikko (huone)</button>
      <span class="grow"></span>
      <input id="roomName" type="text" placeholder="Huoneen nimi (esim. POP1)" />
      <input id="titleAppend" type="text" placeholder="Otsikko (näytetään nimen perässä)" />
      <button id="makeLink">Luo linkki</button>
      <a id="roomLink" class="link" href="#" target="_blank" style="display:none">Avaa huone</a>
    </div>
  </div>

  <div class="right">
    <div class="card" style="margin-bottom:12px;">
      <div class="toggle"><input type="checkbox" id="lockBlack"> <label for="lockBlack">Lukitse mustat ruudut</label></div>
      <div style="font-size:12px;color:#475569;margin-top:6px;">Uudessa huoneessa mustat ovat lukossa oletuksena. Avaa/lukitse tarvittaessa.</div>
    </div>
    <div class="card">
      <div style="font-weight:600; margin-bottom:8px;">Pelaajat</div>
      <div class="names" id="names"></div>
    </div>
  </div>
</div>

<script type="module">
// Turvallinen lataus: jos y-indexeddb ei toimi, käytetään localStorage-varmuutta,
// ja ruudukko renderöidään joka tapauksessa.
import * as Y from 'https://cdn.jsdelivr.net/npm/yjs@13.6.18/+esm';
import { WebsocketProvider } from 'https://cdn.jsdelivr.net/npm/y-websocket@1.5.4/+esm';

(async function(){
  const params = new URLSearchParams(location.search);
  const room = (params.get('room')||'POP1').trim();
  const extraTitle = (params.get('title')||'').trim();
  updateHeader(room, extraTitle);

  // Apufunktio näkyvälle virheilmoitukselle
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  function showError(msg){ if(statusDot){ statusDot.classList.add('err'); statusText.textContent = msg; } }

  // Yjs-asiakirja
  const ydoc = new Y.Doc();

  // Paikallinen pysyvyys: y-indexeddb jos saatavilla, muuten localStorage-backup
  let persistenceOk = false;
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/y-indexeddb@1.0.10/+esm');
    const persist = new mod.IndexeddbPersistence('crossword-'+room.toLowerCase(), ydoc);
    persist.whenSynced.then(()=>{ persistenceOk = true; });
  } catch(e){
    // localStorage fallback
    try {
      const key = 'crossword-ls-'+room.toLowerCase();
      const snap = localStorage.getItem(key);
      if(snap){
        const data = JSON.parse(snap);
        const ycells = ydoc.getMap('cells');
        if(data && data.cells){
          for(const k in data.cells){ ycells.set(k, JSON.stringify(data.cells[k])); }
        }
      }
      // myöhemmin tallennus
      ydoc.on('update', ()=>{
        const ycells = ydoc.getMap('cells');
        const out = { cells:{} };
        ycells.forEach((v,k)=>{ out.cells[k] = JSON.parse(v); });
        localStorage.setItem(key, JSON.stringify(out));
      });
      persistenceOk = true;
      if(statusText) statusText.textContent = 'Paikallinen tallennus käytössä (localStorage)';
    } catch(err){ showError('Paikallinen tallennus ei käytössä'); }
  }

  // WebSocket-sync (valinnainen)
  let provider = null;
  try {
    provider = new WebsocketProvider('wss://demos.yjs.dev', 'crossword-'+room.toLowerCase(), ydoc);
    provider.on('status', (e)=>{
      if(e.status === 'connected'){
        if(statusDot){ statusDot.classList.add('ok'); statusDot.classList.remove('err'); }
        if(statusText) statusText.textContent='Yhdistetty – muutokset synkassa';
      } else {
        if(statusDot){ statusDot.classList.remove('ok'); }
        if(statusText) statusText.textContent = persistenceOk ? 'Ei yhteyttä – tallennetaan paikallisesti' : 'Ei yhteyttä';
      }
    });
    provider.on('connection-error', ()=> showError('Yhteysvirhe – jatketaan paikallisesti'));
  } catch(e){ showError('Yhteyden muodostus epäonnistui'); }

  const ycells = ydoc.getMap('cells');
  const ystate = ydoc.getMap('state');
  const ynames = ydoc.getMap('names');

  const N = 20;
  const gridWrapper = document.getElementById('gridWrapper');
  const lockBlackEl = document.getElementById('lockBlack');
  const namesEl = document.getElementById('names');

  // Oletus: uusi huone -> mustat lukossa
  if(ycells.size === 0 && !ystate.has('lockBlack')) ystate.set('lockBlack', true);
  if(lockBlackEl) lockBlackEl.checked = !!ystate.get('lockBlack');

  function keyFor(r,c){ return r+','+c; }
  function getCell(r,c){ const raw = ycells.get(keyFor(r,c)); return raw?JSON.parse(raw):{ v:'', b:false }; }
  function setCell(r,c,obj){ ycells.set(keyFor(r,c), JSON.stringify(obj)); }

  function focusRC(r,c){ const el = document.querySelector(`.cell input[data-r="${r}"][data-c="${c}"]`); if(el){ el.focus(); el.select(); } }
  function move(r,c,dir){
    if(dir==='left') c = (c>0? c-1: 0);
    if(dir==='right') c = (c<N-1? c+1: N-1);
    if(dir==='up') r = (r>0? r-1: 0);
    if(dir==='down') r = (r<N-1? r+1: N-1);
    focusRC(r,c);
  }

  function render(){
    if(!gridWrapper) return;
    gridWrapper.innerHTML='';
    const topRow=document.createElement('div');
    topRow.className='labels-row';
    topRow.appendChild(document.createElement('div')).className='label-cell';
    for(let c=0;c<N;c++){ const l=document.createElement('div'); l.className='label-cell'; l.textContent=String.fromCharCode(65+c); topRow.appendChild(l); }
    topRow.appendChild(document.createElement('div')).className='label-cell';
    gridWrapper.appendChild(topRow);

    for(let r=0;r<N;r++){
      const row=document.createElement('div'); row.className='grid-row';
      const left=document.createElement('div'); left.className='label-cell'; left.textContent=r+1; row.appendChild(left);
      const grid=document.createElement('div'); grid.className='grid'; grid.style.setProperty('--n',N);
      for(let c=0;c<N;c++){
        const data=getCell(r,c);
        const cell=document.createElement('div');
        cell.className='cell'+(data.b?' black':'');
        const inp=document.createElement('input');
        inp.maxLength=1; inp.value=(data.v||'').toUpperCase();
        inp.dataset.r = r; inp.dataset.c = c;
        inp.addEventListener('input', e=>{
          const v=(e.target.value||'').replace(/[^A-Za-zÅÄÖåäö]/g,'').toUpperCase().slice(0,1);
          e.target.value=v; setCell(r,c,{v,b:data.b});
          if(v){ move(r,c,'right'); }
        });
        inp.addEventListener('keydown', e=>{
          if(e.key==='ArrowLeft'){ e.preventDefault(); move(r,c,'left'); }
          else if(e.key==='ArrowRight' || e.key==='Enter'){ e.preventDefault(); move(r,c,'right'); }
          else if(e.key==='ArrowUp'){ e.preventDefault(); move(r,c,'up'); }
          else if(e.key==='ArrowDown'){ e.preventDefault(); move(r,c,'down'); }
          else if(e.key==='Backspace'){
            if(inp.value){ e.preventDefault(); setCell(r,c,{v:'', b:data.b}); inp.value=''; }
            else { e.preventDefault(); const nc=Math.max(0,c-1); setCell(r,nc,{...getCell(r,nc), v:''}); focusRC(r,nc); }
          }
        });
        cell.appendChild(inp);
        cell.addEventListener('click', e=>{ if(e.altKey && !ystate.get('lockBlack')){ setCell(r,c,{v:data.v,b:!data.b}); }});
        grid.appendChild(cell);
      }
      row.appendChild(grid);
      const right=document.createElement('div'); right.className='label-cell'; right.textContent=r+1; row.appendChild(right);
      gridWrapper.appendChild(row);
    }
    const bottomRow=document.createElement('div'); bottomRow.className='labels-row';
    bottomRow.appendChild(document.createElement('div')).className='label-cell';
    for(let c=0;c<N;c++){ const l=document.createElement('div'); l.className='label-cell'; l.textContent=String.fromCharCode(65+c); bottomRow.appendChild(l); }
    bottomRow.appendChild(document.createElement('div')).className='label-cell';
    gridWrapper.appendChild(bottomRow);
  }

  ycells.observe(render); ystate.observe(()=>{ if(lockBlackEl) lockBlackEl.checked=!!ystate.get('lockBlack'); }); render();

  // Tallennus / lataus
  function exportJSON(){
    const out = { n:N, cells:{} };
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const d = getCell(r,c);
      if(d.v || d.b) out.cells[keyFor(r,c)] = d;
    }
    const blob = new Blob([JSON.stringify(out)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `ristikko-${room}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  }
  function importJSON(file){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if(!data || !data.cells) throw new Error('Virheellinen tiedosto');
        ydoc.transact(()=>{ ycells.clear(); for(const k in data.cells){ ycells.set(k, JSON.stringify(data.cells[k])); } });
      } catch(e){ alert('Lataus epäonnistui: '+e.message); }
    };
    reader.readAsText(file);
  }
  document.getElementById('save').addEventListener('click', exportJSON);
  const loadInput = document.getElementById('load');
  document.getElementById('loadBtn').addEventListener('click', ()=> loadInput.click());
  loadInput.addEventListener('change', ()=>{ if(loadInput.files[0]) importJSON(loadInput.files[0]); });

  // Tyhjennä huone (poistaa kaikki solut)
  document.getElementById('clear').addEventListener('click', ()=>{
    if(confirm('Tyhjennetäänkö koko ristikko tältä huoneelta?')) ycells.clear();
  });

  // Lukitse mustat (jaettu asetus)
  document.getElementById('lockBlack').addEventListener('change', (e)=>{ ystate.set('lockBlack', !!e.target.checked); });

  // Huonelinkki (nimi + otsikko)
  const roomName = document.getElementById('roomName');
  const titleAppend = document.getElementById('titleAppend');
  const roomLink = document.getElementById('roomLink');
  document.getElementById('makeLink').addEventListener('click', ()=>{
    const name = (roomName.value || 'POP1').trim();
    const extra = (titleAppend.value || '').trim();
    const url = new URL(location.href);
    url.searchParams.set('room', name);
    if(extra) url.searchParams.set('title', extra);
    roomLink.href = url.toString();
    roomLink.style.display = 'inline';
    roomLink.textContent = 'Avaa huone: '+name+(extra? ' — '+extra : '');
  });

  // Pelaajanimet (10 kenttää, synkattu)
  const namesEl = document.getElementById('names');
  const nameInputs = [];
  function buildNames(){
    if(!namesEl) return;
    namesEl.innerHTML='';
    for(let i=0;i<10;i++){
      const inp=document.createElement('input');
      inp.placeholder = 'Pelaaja '+(i+1);
      inp.value = ynames.get(String(i)) || '';
      inp.addEventListener('input', ()=>{ ynames.set(String(i), inp.value); });
      nameInputs.push(inp); namesEl.appendChild(inp);
    }
  }
  function syncNamesFromDoc(){
    for(let i=0;i<nameInputs.length;i++){
      const v = ynames.get(String(i)) || '';
      if(nameInputs[i].value !== v){ nameInputs[i].value = v; }
    }
  }
  ynames.observe(syncNamesFromDoc);
  buildNames();
})();
</script>
</body>
</html>
